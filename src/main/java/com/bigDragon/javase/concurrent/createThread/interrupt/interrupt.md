# 简介
在Java中，Thread.interrupt() 方法用于中断线程的执行。它通过将线程的中断状态设置为 true 来达到这个目的。但是，它并不会立即终止线程，
而是提出一个中断请求，线程可以通过检查自身的中断状态来决定是否响应这个中断请求。
# 中断相关的三个方法
在Java中，提供了以下3个有关线程中断的方法
```
//中断线程（实例方法）
public void Thread.interrupt();

//判断线程是否被中断（实例方法）
public boolean Thread.isInterrupted();

//判断是否被中断并清除当前中断状态（静态方法）
public static boolean Thread.interrupted();
```

# 中断两种情况
* 一种是当线程处于阻塞状态或者试图执行一个阻塞操作时，我们可以使用实例方法interrupt()进行线程中断，执行中断操作后将会抛出interruptException异常(该异常必须捕捉无法向外抛出)并将中断状态复位。
* 另外一种是当线程处于运行状态时，我们也可调用实例方法interrupt()进行线程中断，但同时必须手动判断中断状态，并编写中断线程的代码(其实就是结束run方法体的代码)。
  * 如果不手动判断，线程会继续执行不会影响
* 实际使用时，有时需要在编码时可能需要兼顾线程运行和线程阻塞两种情况
```
public void run(){
    try {
    //判断当前线程是否已中断,注意interrupted方法是静态的,执行后会对中断状态进行复位
    while (!Thread.interrupted()) {
        TimeUnit.SECONDS.sleep(2);
    }
    } catch (InterruptedException e) {

    }
}

```
# 解释和注意事项
* 中断状态检查：
线程通过调用 Thread.currentThread().isInterrupted() 来检查自己的中断状态。如果中断状态为 true，则应该终止线程的执行。
* 中断异常处理：
在线程可能抛出 InterruptedException 异常的地方（如调用了 sleep()、wait()、join() 等方法时），需要捕获这个异常并处理中断请求。通常情况下，可以在捕获到 InterruptedException 后，通过判断中断状态来决定是否继续执行或者结束线程。
* 中断响应：
当调用 myThread.interrupt() 后，如果线程当前正在阻塞状态（如调用 sleep()、wait()、join() 等方法），它会抛出 InterruptedException 异常，并清除中断状态。如果线程没有处于阻塞状态，它仍然可以通过检查中断状态来决定是否终止执行。
* 线程的中断状态：
中断状态不会自动清除，一旦线程响应了中断请求，中断状态将保持为 true。如果需要在捕获到 InterruptedException 后重新设置中断状态，可以调用 Thread.currentThread().interrupt()。
* 合理使用中断：
中断是一种协作机制，用于请求线程停止正在执行的任务。在使用中断时，需要谨慎处理线程的状态和执行逻辑，确保线程安全和正确的中断响应。

# interrupt不是强制终止线程的机制
在Java中，线程中断是一种协作机制，而不是强制终止线程的机制。这种设计有几个重要的理由：

* 线程安全性和资源释放： 如果线程被强制终止，可能会导致未释放的资源，如文件句柄、数据库连接等，造成资源泄露和数据损坏。通过协作的方式，线程可以在适当的时机释放资源，保证系统的稳定性和可靠性。

* 线程状态的管理： 强制终止线程会导致线程的状态不可预测，可能会破坏程序的一致性和可维护性。通过中断机制，线程可以在合适的时机检查自身的中断状态，并进行安全的清理操作。

* 异常的处理和上下文切换： 异常的抛出和处理是一种相对昂贵的操作，尤其是在高并发和性能敏感的环境中。通过中断机制，可以更加灵活地控制线程的行为，避免不必要的异常捕获和处理成本。

* 协作性和可控性： 中断机制使得线程可以在多个点上进行协作，例如在循环中检查中断状态、响应外部条件等。这种协作性可以更好地实现线程间的同步和通信，提高程序的可控性和可维护性。

总结来说，Java中采用手动中断线程的方式，是为了确保程序的健壮性和可靠性，同时提供了更多的灵活性和控制能力，使得线程的管理和资源的释放更加安全和可预测。因此，程序员可以根据具体的业务需求和线程逻辑，合理地设计和管理线程的中断处理。
