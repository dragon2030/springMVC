## 虚假唤醒(Spurious Wakeup)详解

### 1. 什么是虚假唤醒

虚假唤醒是指线程在没有收到明确的唤醒通知(如notify/notifyAll)的情况下，从wait()状态中被唤醒的现象。这种现象可能由以下原因引起：

- 操作系统层面的线程调度机制
- JVM实现细节
- 底层硬件或系统中断的影响

### 2. 为什么需要防范虚假唤醒

虚假唤醒会导致程序逻辑错误，因为线程可能在条件尚未满足时就继续执行。例如在生产者-消费者模式中，消费者可能在缓冲区为空时被虚假唤醒，如果不检查条件就直接消费，会导致异常。

### 3. 如何防范虚假唤醒

**正确做法**：使用while循环而不是if语句检查条件

```
synchronized (lock) {
    while (!condition) {  // 使用while而不是if
        lock.wait();
    }
    // 执行操作
}
```

**错误做法**：

```
synchronized (lock) {
    if (!condition) {  // 使用if会有虚假唤醒风险
        lock.wait();
    }
    // 执行操作
}
```

### 4. 底层原理

在操作系统层面，wait()的实现通常涉及以下步骤：

1. 将线程加入等待队列
2. 释放锁
3. 进入等待状态
4. 被唤醒后重新获取锁

在第3步和第4步之间，即使没有notify调用，系统也可能因各种原因唤醒线程。因此，重新检查条件是必要的。