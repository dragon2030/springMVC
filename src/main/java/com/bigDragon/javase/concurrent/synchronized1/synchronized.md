**synchronized实现原理**
# synchronized的三种应用方式
**synchronized关键字最主要有以下3种应用方式**
* 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁
* 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁
* 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。
# synchronized底层语义原理

# Java对象头
在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充
* Java头对象，它实现synchronized的锁对象的基础，synchronized使用的锁对象是存储在Java对象头里的，jvm中采用2个字来存储对象头(如果对象是数组则会分配3个字，多出来的1个字记录的是数组长度)，其主要结构是由Mark Word 和 Class Metadata Address 组成
  * Mark Word	存储对象的hashCode、锁信息或分代年龄或GC标志等信息
  * Class Metadata Address	类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的实例。
* 实例变量：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。
* 填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐，这点了解即可。

# Monitor 重量级锁
* synchronized的对象锁
* 锁标识位为10 
* 其中指针指向的是monitor对象
* 在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现
  * _WaitSet：
    * _WaitSet是一个用于管理处于等待状态的线程集合。当一个线程调用对象的 wait() 方法时，它会释放对象的监视器锁，并进入_WaitSet中等待被唤醒。
    * _WaitSet中的线程等待其他线程调用相同对象的 notify() 或 notifyAll() 方法来唤醒它们。
  * EntryList（等待队列）：
    * EntryList是一个更具体的概念，用于表示在对象监视器上等待锁的线程队列。在Java的实现中，EntryList是_WaitSet的一部分，用于存放处于 wait() 状态的线程。】
## synchronized底层原理javap反编译
  * synchronized代码块底层原理：monitorenter 和 monitorexit
  * synchronized方法底层原理：ACC_SYNCHRONIZED
## 重量级锁 效率低下
* 因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现的，而操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。
*  庆幸的是在Java 6之后Java官方对从JVM层面对synchronized较大优化，所以现在的synchronized锁效率也优化得很不错了，Java 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁
### 用户态内核态切换
#### 用户态内核态
* 用户态（User Mode）：
  * 在用户态运行的程序只能访问受限资源和指令集，如应用程序。用户态下运行的程序无法直接访问系统硬件和敏感资源，必须通过操作系统提供的服务来实现对系统资源的访问和操作。
* 内核态（Kernel Mode）：
  * 内核态具有更高的权限和更广泛的访问权限，可以直接访问系统硬件和所有内存空间。在内核态下运行的代码可以执行特权指令、管理硬件设备、执行中断处理等敏感操作。
#### 切换过程
  * 切换从用户态到内核态或从内核态到用户态的过程涉及以下几个关键步骤：
1. 触发切换条件：
   * 当用户态的程序需要访问操作系统内核提供的服务或需要执行特权操作时，例如进行系统调用（如文件操作、网络通信）、处理异常（如内存访问异常）、处理中断（如硬件中断）等情况，就会触发从用户态到内核态的切换。
2. 保存上下文：
   * 在切换之前，操作系统会保存当前用户态的程序执行上下文（如寄存器状态、程序计数器值等），以便后续恢复执行。
3. 切换到内核态：
   * 当触发切换条件时，处理器会执行特定的切换指令，将当前程序的执行权限从用户态切换到内核态。这包括改变处理器的特权级别和访问权限。
4. 执行内核态代码：
   * 在内核态下，操作系统会执行相应的内核代码来处理请求或异常，如处理系统调用、中断服务例程等。
5. 恢复用户态：
   * 处理完请求或异常处理后，操作系统会恢复之前保存的用户态程序上下文，并将执行权限切换回用户态，使得用户程序可以继续执行。
#### 作用和重要性
* 用户态和内核态切换的过程是操作系统实现多任务调度、资源管理和安全保护的基础。它确保了系统的稳定性和安全性，同时允许用户程序通过系统调用等方式间接访问和使用系统的硬件和资源。
【用户态下的程序相互之间和对系统资源的访问受到限制，通过操作系统提供的接口（如系统调用）来间接访问和使用系统资源。操作系统可以对这些访问进行审查和控制，避免恶意或非法操作。】
# 针对加锁操作的优化手段
## 偏向锁
* 偏向锁是一种针对加锁操作的优化手段
* 经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。
* 偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。
## 轻量级锁
* 倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。
* 轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。
* 需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。
## 锁膨胀
锁膨胀.md
## 轻量到重量的自旋锁
这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高
## 锁消除
Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append
# synchronized的可重入性
【new ReentrantTest().synchronizedReentrant();】
* 注意由于synchronized是基于monitor实现的，因此每次重入，monitor中的计数器仍会加1。

# synchronized 实现内存可见性的机制
* synchronized 关键字在 Java 中不仅提供了线程互斥的功能，还保证了内存可见性
## 内存屏障（Memory Barrier）
* synchronized 通过插入内存屏障来实现可见性：
  * 进入同步块时（获取锁）：会插入一个 Load Barrier（读屏障），强制从主内存重新加载变量，使线程能看到其他线程的最新修改
  * 退出同步块时（释放锁）：会插入一个 Store Barrier（写屏障），强制将工作内存中的修改刷新到主内存
## Happens-Before 关系
* 根据 Java 内存模型的 happens-before 原则：
  * 监视器锁规则：对一个监视器锁的解锁 happens-before 于随后对这个监视器锁的加锁
  * 这意味着前一个线程在同步块中的所有修改对后一个进入同步块的线程都是可见的
## 内存屏障（Memory Barrier）与 happens-before 的关系
* 内存屏障是 happens-before 原则在处理器层面的实现机制，而 happens-before 是 Java 内存模型提供给开发者的抽象保证。synchronized 通过合理插入 Load Barrier 和 Store Barrier 来满足监视器锁规则的 happens-before 要求，从而保证内存可见性。
* 1. Load Barrier（读屏障）
   * 作用：确保在该屏障之后的读操作能看到该屏障之前的所有写操作结果
   * 对应 happens-before：实现"先写后读"的可见性保证
   * 在 synchronized 中的表现：进入同步块时的读屏障确保线程能看到前一个线程在同步块中的所有修改
* 2. Store Barrier（写屏障）
   * 作用：确保在该屏障之前的写操作在该屏障之后对其他线程可见
   * 对应 happens-before：实现"先写后写"或"先写后读"的可见性保证
   * 在 synchronized 中的表现：退出同步块时的写屏障确保当前线程的修改能被后续进入同步块的线程看到
## 实际效果
* 当一个线程退出同步块时：
  * 所有修改过的变量会被立即刷新到主内存
  * 释放锁操作会强制写入主内存
* 当另一个线程进入同步块时：
  * 获取锁操作会使处理器缓存失效
  * 变量会从主内存重新加载
* 这种机制确保了线程间的操作按顺序可见，避免了内存可见性问题。

# 博客
* https://blog.csdn.net/javazejian/article/details/72828483?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522a3f75f0d7fc3c697ce9d94e12a615c5f%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=a3f75f0d7fc3c697ce9d94e12a615c5f&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-72828483-null-null.142^v102^pc_search_result_base4&utm_term=Synchronized%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86&spm=1018.2226.3001.4187
> 【主要讲了1、synchronized的详细原理 2、interrupt 3、notify/notifyAll和wait】
