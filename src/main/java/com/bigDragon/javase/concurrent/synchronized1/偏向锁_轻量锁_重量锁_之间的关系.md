偏向锁 轻量锁 重量锁 之间的关系 详细解释
Java对象锁的升级过程：偏向锁→轻量级锁→重量级锁
Java中的锁机制经历了多次优化，形成了从偏向锁到轻量级锁再到重量级锁的升级路径。这种设计是为了在不同竞争场景下都能获得最佳性能。

1. 偏向锁（Biased Locking）
   设计目的：减少无竞争情况下的同步开销（适用于只有一个线程访问同步块的场景）

特点：

假设"锁总是由同一线程获得"

第一次获得锁时，在对象头和栈帧中记录偏向的线程ID

后续该线程进入同步块时不需要任何同步操作（CAS、锁申请等）

适用于单线程重复访问同步块的场景

工作流程：

检查Mark Word中的线程ID是否指向当前线程

如果是，直接执行同步代码

如果不是，检查偏向锁标志是否为1：

为0：尝试用CAS竞争锁

为1：尝试撤销偏向锁（偏向锁撤销需要等待全局安全点）

优点：无竞争时完全无同步开销
缺点：存在锁撤销的开销

2. 轻量级锁（Lightweight Locking）
   设计目的：当有少量线程竞争时，避免直接使用重量级锁带来的性能损耗

特点：

基于"大多数同步块在生命周期内都不会有竞争"的假设

使用CAS操作替代互斥量

线程在执行同步块前，JVM会在当前线程的栈帧中创建锁记录（Lock Record）

将对象头中的Mark Word复制到锁记录中（Displaced Mark Word）

然后尝试用CAS将对象头中的Mark Word替换为指向锁记录的指针

工作流程：

在进入同步块前，JVM在当前线程栈帧中创建锁记录空间

将对象头中的Mark Word复制到锁记录中（Displaced Mark Word）

尝试用CAS将对象头替换为指向锁记录的指针

成功：获取轻量级锁

失败：检查是否当前线程已经持有锁（重入）

是：设置锁记录第一部分为null，起到重入计数器作用

否：锁膨胀为重量级锁

优点：在没有竞争或竞争不激烈时性能很好
缺点：自旋会消耗CPU，长时间自旋不成功会升级为重量级锁

3. 重量级锁（Heavyweight Locking）
   设计目的：处理高竞争情况下的线程同步

特点：

基于操作系统的互斥量（Mutex）实现

线程阻塞和唤醒需要从用户态切换到内核态，开销大

涉及操作系统的线程调度机制

通过ObjectMonitor对象实现（包含等待队列、拥有者线程等）

工作流程：

当轻量级锁自旋超过阈值（或竞争激烈）时，膨胀为重量级锁

对象头中的Mark Word指向一个Monitor对象

未获取锁的线程进入阻塞状态，放入等待队列

锁释放时唤醒等待队列中的线程

优点：能有效处理高竞争情况
缺点：上下文切换开销大

锁升级的全过程（锁膨胀）
初始状态：对象刚创建时，处于无锁状态（可能可偏向）

第一次获取锁：

如果偏向锁可用，进入偏向模式（记录线程ID）

否则直接尝试轻量级锁

出现竞争（另一个线程尝试获取锁）：

偏向锁撤销：暂停拥有锁的线程，检查是否还在同步块中

如果已退出：恢复到无锁或可偏向状态

如果仍在执行：升级为轻量级锁

轻量级锁竞争：

成功：继续执行

失败（自旋超过阈值）：膨胀为重量级锁

重量级锁：后续所有竞争都走操作系统同步机制

锁的优缺点对比
锁类型	优点	缺点	适用场景
偏向锁	无竞争时完全无同步开销	锁撤销有开销	单线程重复访问同步块
轻量级锁	竞争不激烈时避免线程阻塞	自旋消耗CPU	多线程交替执行同步块
重量级锁	能处理高竞争情况	上下文切换开销大	多线程高竞争场景
JVM参数调优
-XX:+UseBiasedLocking：启用偏向锁（JDK 15后默认禁用）

-XX:BiasedLockingStartupDelay=4000：偏向锁启动延迟（毫秒）

-XX:+UseSpinning：启用自旋（轻量级锁）

-XX:PreBlockSpin=10：轻量级锁自旋次数

现代JVM的变化
从JDK 15开始，偏向锁被默认禁用（但仍可通过参数启用），因为：

现代应用大多是多线程高竞争的

偏向锁的维护成本高

其他优化技术（如逃逸分析）可以替代部分场景

理解这些锁机制及其升级过程，有助于编写高性能的并发代码和进行JVM调优。
